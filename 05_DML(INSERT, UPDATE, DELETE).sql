-- DML : INSERT, UPDATE, DELETE

-- 테스트용 테이블 생성
CREATE TABLE EMPLOYEE2 AS SELECT * FROM EMPLOYEE;
CREATE TABLE DEPARTMENT2 AS SELECT * FROM DEPARTMENT;

-- 1. INSERT : 테이블에 새로운 행을 추가하는 구문
-- 1) INSERT INTO 테이블명 VAULES(데이터, 데이터...); : 테이블에 있는 모든 컬럼에 대한 값 INSERT할 때 사용
INSERT INTO EMPLOYEE2
VALUES ('900', '홍길동', '991214-1234567', 'hong_gd@or.kr', '01011111111', 'D1', 'J7', 'S3', 4300000, 0.2, 200, SYSDATE, NULL, 'N');

ROLLBACK;

-- 2) INSERT INTO 테이블명(컬럼명1, 컬럼명2, ...) VALUES(데이터1, 데이터2, ...);
-- : 테이블에 내가 선택한 컬럼에 대한 값만 INSERT할 때 사용, 선택되지 않은 컬럼은 NULL 또는 DEFAULT 존재 시, DEFAULT 설정 값 삽입됨
INSERT INTO EMPLOYEE2 (EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL, SALARY)
VALUES ('900', '홍길동', '991214-1234567', 'hong_gd@or.kr', '01011111111', 'D1', 'J7', 'S3', '4300000');
-- 복사한 테이블은 원본의 디폴트, comment가 따라오지 않음
SELECT * FROM EMPLOYEE2 WHERE EMP_ID = '900';
COMMIT; -- 홍길동... 데이터 DB에 영구 저장
ROLLBACK;
SELECT * FROM EMPLOYEE2 WHERE EMP_ID = '900'; -- 영구 저장(COMMIT)하였으므로 롤백하더라도 조회 가능(되돌리기 불가능)

-- INSERT 시 VALUES 대신 서브쿼리 사용 가능
CREATE TABLE EMP_01(
	EMP_ID NUMBER, EMP_NAME VARCHAR2(30), DEPT_TITLE VARCHAR2(20)
);
SELECT * FROM EMP_01;

SELECT EMP_ID, EMP_NAME, DEPT_TITLE FROM EMPLOYEE2 LEFT JOIN DEPARTMENT2 ON (DEPT_CODE = DEPT_ID)

-- 서브 쿼리(SELECT EMP_ID...)의 결과(RESULT SET)를 EMP_01 테이블에 INSERT하기
-- > SELECT 조회 결과의 데이터 타입, 컬럼 개수가 INSERT하려는 테이블의 컬럼과 일치해야 함
INSERT INTO EMP_01(
	SELECT EMP_ID, EMP_NAME, DEPT_TITLE FROM EMPLOYEE2 LEFT JOIN DEPARTMENT2 ON (DEPT_CODE = DEPT_ID)
);

-- 숫자 타입 : 왼쪽 정렬, 문자열 : 오른쪽 정렬
-- 문자열 내에 실제로 이루어진 값이 숫자로만 이루어졌다면 > NUMBER 타입 내에도 들어갈 수 있음! (NUMBER 타입으로 출력됨)
SELECT * FROM EMP_01;

-- 2. UPDATE : 내용을 바꾸거나 추가해 최신화
-- [작성법]
-- UPDATE 테이블명 SET 컬럼명 = 바꿀값 : 까지 작성하면, 포함된 모든 행 업데이트
-- [WHERE 컬럼명 비교연산자 비교값]; : *WHERE절은 옵션이나 WHERE절 조건 중요함*

-- DEPARTMENT2 테이블에서 DEPT_ID가 'D9'인 부서의 DEPT_TITLE을 '전략기획팀'으로 수정
SELECT * FROM DEPARTMENT2 WHERE DEPT_ID = 'D9'; -- DEPARTMENT2 테이블에서 DEPT_ID가 'D9'인 부서 정보 조회
UPDATE DEPARTMENT2 SET DEPT_TITLE = '전략기획팀' WHERE DEPT_ID = 'D9'

-- *조건절을 설정하지 않고 UPDATE 구문 실행할 시 > 모든 행의 컬럼값이 변경됨
UPDATE DEPARTMENT2 SET DEPT_TITLE = '기술연구팀';
SELECT * FROM DEPARTMENT2;

-- EMPLOYEE2 테이블에서 BONUS를 받지 않는 사원의 BONUS를 0.1로 변경
UPDATE EMPLOYEE2 SET BONUS = '0.1' WHERE BONUS IS NULL;	
SELECT * FROM EMPLOYEE2;

ROLLBACK;

-- 여러 컬럼을 한 번에 수정할 시, 콤마로 컬럼 구분
-- D9 / 총무부 --> D0 / 전략기획팀 으로 수정
UPDATE DEPARTMENT2 SET DEPT_ID = 'D0', DEPT_TITLE = '전략기획팀'
WHERE DEPT_ID = 'D9' AND DEPT_TITLE = '총무부';
SELECT * FROM DEPARTMENT2;

-- *UPDATE 시에도 서브 쿼리 사용 가능
-- [작성법]
-- UPDATE 테이블명 SET 컬럼명 = (서브쿼리)

-- EMPLOYEE2 테이블에서 방명수 사원의 급여와 보너스율을 유재식 사원과 동일하게 변경해주기
SELECT * FROM EMPLOYEE2;
SELECT SALARY FROM EMPLOYEE2 WHERE EMP_NAME = '유재식'; -- 3,400,000
SELECT BONUS FROM EMPLOYEE2 WHERE EMP_NAME = '유재식'; -- 0.2

UPDATE EMPLOYEE2 SET
SALARY = (SELECT SALARY FROM EMPLOYEE2 WHERE EMP_NAME = '유재식'),
BONUS = (SELECT BONUS FROM EMPLOYEE2 WHERE EMP_NAME = '유재식')
WHERE EMP_NAME = '방명수';

SELECT EMP_NAME, SALARY, BONUS FROM EMPLOYEE2 WHERE EMP_NAME IN ('유재식', '방명수');

-- 3. MERGE(병합) : 구조가 같은 두 개의 테이블을 하나로 합치는 기능
-- 테이블에서 지정하는 조건의 값이 존재하면 UPDATE, 없으면 ISNERT

CREATE TABLE EMP_M01 AS SELECT * FROM EMPLOYEE;
CREATE TABLE EMP_M02 AS SELECT * FROM EMPLOYEE WHERE JOB_CODE = 'J4';

SELECT * FROM EMP_M01;
SELECT * FROM EMP_M02;

INSERT INTO EMP_M02 VALUES(999, '곽두원', '561016-1234567', 'kwack_dw@or.kr', '01011112222', 'D9', 'J4', 'S1', 9000000, 0.5, NULL, SYSDATE, NULL, NULL);

SELECT * FROM EMP_M01; -- 23명 
SELECT * FROM EMP_M02; -- 5명(기존4 + 신규1)

UPDATE EMP_M02 SET SALARY = 0;

MERGE INTO EMP_M01 USING EMP_M02 ON(EMP_M01.EMP_ID = EMP_M02.EMP_ID)
WHEN MATCHED THEN
UPDATE SET
	EMP_M01.EMP_NAME = EMP_M02.EMP_NAME,
	EMP_M01.EMP_NO = EMP_M02.EMP_NO,
	EMP_M01.EMAIL = EMP_M02.EMAIL,
	EMP_M01.PHONE = EMP_M02.PHONE,
	EMP_M01.DEPT_CODE = EMP_M02.DEPT_CODE,
	EMP_M01.JOB_CODE = EMP_M02.JOB_CODE,
	EMP_M01.SAL_LEVEL = EMP_M02.SAL_LEVEL,
	EMP_M01.SALARY = EMP_M02.SALARY,
	EMP_M01.BONUS = EMP_M02.BONUS,
	EMP_M01.MANAGER_ID = EMP_M02.MANAGER_ID,
	EMP_M01.HIRE_DATE = EMP_M02.HIRE_DATE,
	EMP_M01.ENT_DATE = EMP_M02.ENT_DATE,
	EMP_M01.ENT_YN = EMP_M02.ENT_YN
WHEN NOT MATCHED THEN
INSERT VALUES(EMP_M02.EMP_ID, EMP_M02.EMP_NAME, EMP_M02.EMP_NO, EMP_M02.EMAIL, 
	         EMP_M02.PHONE, EMP_M02.DEPT_CODE, EMP_M02.JOB_CODE, EMP_M02.SAL_LEVEL,
	         EMP_M02.SALARY, EMP_M02.BONUS, EMP_M02.MANAGER_ID, EMP_M02.HIRE_DATE, 
	         EMP_M02.ENT_DATE, EMP_M02.ENT_YN);

SELECT * FROM EMP_M01; -- 24행(M01 + M02에서 신규 추가한 한 행), 급여가 0원인 경우 : M02 테이블에 있는 사람들만 UPDATE

COMMIT;

-- 4. DELETE : 테이블의 행을 삭제하는 구문
-- [작성법] : DELETE FROM 테이블명 [WHERE 조건 설정];
-- WHERE 조건 설정하지 않으면, 모든 행이 삭제

-- 홍길동 삭제하기
DELETE FROM EMPLOYEE2 WHERE EMP_NAME = '홍길동';
SELECT * FROM EMPLOYEE2 WHERE EMP_NAME = '홍길동';

ROLLBACK; -- 마지막 커밋 시점까지 되돌아감 > 홍길동 조회 가능
SELECT * FROM EMPLOYEE2 WHERE EMP_NAME = '홍길동';

-- EMPLOYEE2 테이블 행 전체 삭제
DELETE FROM EMPLOYEE2; -- 24행 전체 삭제
SELECT * FROM EMPLOYEE2;

ROLLBACK;

-- 5. TRUNCATE(DDL) : 테이블의 전체 행을 삭제하는 DDL으로 DELETE보다 수행 속도가 빠름
-- ROLLBACK을 통한 복구 불가능

-- 테스트용 테이블 생성
CREATE TABLE EMPLOYEE3 AS SELECT * FROM EMPLOYEE2;
SELECT * FROM EMPLOYEE3;

-- TRUNCATE로 삭제하기
TRUNCATE TABLE EMPLOYEE3;

-- 삭제 확인
SELECT * FROM EMPLOYEE3; -- 행 전부 삭제

ROLLBACK;
SELECT * FROM EMPLOYEE3; -- 롤백 수행 후에도 TRUNCATE 결과 유지 (복구 불가)

-- DELETE = 휴지통에 버리기(복구 가능), TRUNCATE = 완전 삭제(복구 불가능)